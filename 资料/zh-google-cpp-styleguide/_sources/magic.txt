4. 来自 Google 的奇技
------------------------

Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.

4.1. 智能指针
~~~~~~~~~~~~~~~~~~~~

.. tip::
    如果确实需要使用智能指针的话, ``scoped_ptr`` 完全可以胜任. 你应该只在非常特定的情况下使用 ``std::tr1::shared_ptr``, 例如 STL 容器中的对象. 任何情况下都不要使用 ``auto_ptr``.

"智能" 指针看上去是指针, 其实是附加了语义的对象. 以 ``scoped_ptr`` 为例, ``scoped_ptr`` 被销毁时, 它会删除所指向的对象. ``shared_ptr`` 也是如此, 并且 ``shared_ptr`` 实现了引用计数, 所以最后一个 ``shared_ptr`` 对象析构时, 如果检测到引用次数为 0，就会销毁所指向的对象.

一般来说，我们倾向于设计对象隶属明确的代码, 最明确的对象隶属是根本不使用指针, 直接将对象作为一个作用域或局部变量使用. 另一种极端做法是, 引用计数指针不属于任何对象. 这种方法的问题是容易导致循环引用, 或者导致某个对象无法删除的诡异状态, 而且在每一次拷贝或赋值时连原子操作都会很慢.

虽然不推荐使用引用计数指针, 但有些时候它们的确是最简单有效的解决方案.

(YuleFox 注: 看来, Google 所谓的不同之处, 在于尽量避免使用智能指针 :D, 使用时也尽量局部化, 并且, 安全第一)

4.2. cpplint
~~~~~~~~~~~~~~~~~~~~

.. tip::
    使用 ``cpplint.py`` 检查风格错误.
    
``cpplint.py`` 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 用行注释 ``// NOLINT`` 可以忽略误报.

某些项目会指导你如何使用他们的项目工具运行 ``cpplint.py``. 如果你参与的项目没有提供, 你可以单独下载 `cpplint.py <http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py>`_.
